<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>结构化绑定1 :: 暮鼓晨钟</title>
    <link>https://example.org/%E6%97%A5%E5%B8%B8%E6%8B%BE%E8%B6%A3/c&#43;&#43;11/c&#43;&#43;17&#43;/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A1/index.html</link>
    <description>语法与使用场景 基础语法 1auto [变量1, 变量2, ...] = 表达式; // 拷贝绑定 2auto&amp; [变量1, 变量2, ...] = 表达式; // 引用绑定 3const auto&amp; [变量1, 变量2, ...] = 表达式; // 常引用绑定 实用场景示例 场景1：遍历关联容器（C++17+） 1#include &lt;iostream&gt; 2#include &lt;map&gt; 3#include &lt;string&gt; 4 5int main() { 6 std::map&lt;std::string, int&gt; scores = { 7 {&#34;Alice&#34;, 95}, 8 {&#34;Bob&#34;, 87}, 9 {&#34;Charlie&#34;, 92} 10 }; 11 12 // 传统方式 13 for (auto it = scores.begin(); it != scores.end(); ++it) { 14 std::cout &lt;&lt; it-&gt;first &lt;&lt; &#34;: &#34; &lt;&lt; it-&gt;second &lt;&lt; &#34;\n&#34;; 15 } 16 17 // 结构化绑定 - 优雅且高效 18 for (const auto&amp; [name, score] : scores) { 19 std::cout &lt;&lt; name &lt;&lt; &#34;: &#34; &lt;&lt; score &lt;&lt; &#34;\n&#34;; 20 } 21 22 return0; 23} 场景2：解构多返回值（C++17+） 1#include &lt;tuple&gt; 2#include &lt;string&gt; 3#include &lt;iostream&gt; 4 5// 返回多个值：学生姓名、成绩、排名 6std::tuple&lt;std::string, double, int&gt; getStudentInfo(int id) { 7 returnstd::make_tuple(&#34;David&#34;, 88.5, 3); 8} 9 10int main() { 11 // 传统解包方式 12 auto info = getStudentInfo(1); 13 std::string name = std::get&lt;0&gt;(info); 14 double score = std::get&lt;1&gt;(info); 15 int rank = std::get&lt;2&gt;(info); 16 17 // 结构化绑定 - 直观明了 18 auto [name2, score2, rank2] = getStudentInfo(1); 19 std::cout &lt;&lt; name2 &lt;&lt; &#34; - Score: &#34; &lt;&lt; score2 20 &lt;&lt; &#34;, Rank: &#34; &lt;&lt; rank2 &lt;&lt; &#34;\n&#34;; 21 22 return0; 23} 场景3：处理结构体数据（C++17+） 1#include &lt;iostream&gt; 2#include &lt;string&gt; 3#include &lt;vector&gt; 4 5struct Point { 6 double x; 7 double y; 8 double z; 9}; 10 11std::vector&lt;Point&gt; getPoints() { 12 return {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}}; 13} 14 15int main() { 16 // 传统方式 - 冗长 17 auto points = getPoints(); 18 for (const auto&amp; p : points) { 19 std::cout &lt;&lt; &#34;(&#34; &lt;&lt; p.x &lt;&lt; &#34;, &#34; &lt;&lt; p.y &lt;&lt; &#34;, &#34; &lt;&lt; p.z &lt;&lt; &#34;)\n&#34;; 20 } 21 22 // 结构化绑定 - 简洁 23 for (const auto&amp; [x, y, z] : getPoints()) { 24 std::cout &lt;&lt; &#34;(&#34; &lt;&lt; x &lt;&lt; &#34;, &#34; &lt;&lt; y &lt;&lt; &#34;, &#34; &lt;&lt; z &lt;&lt; &#34;)\n&#34;; 25 } 26 27 return0; 28} 场景4：数组解构（C++17+） 1#include &lt;iostream&gt; 2 3int main() { 4 int coordinates[3] = {10, 20, 30}; 5 6 // 解构数组元素 7 auto [x, y, z] = coordinates; 8 9 std::cout &lt;&lt; &#34;X: &#34; &lt;&lt; x &lt;&lt; &#34;, Y: &#34; &lt;&lt; y &lt;&lt; &#34;, Z: &#34; &lt;&lt; z &lt;&lt; &#34;\n&#34;; 10 11 return 0; 12} 场景5：引用绑定修改原数据（C++17+） 1#include &lt;iostream&gt; 2#include &lt;array&gt; 3 4void modifyArray() { 5 std::array&lt;int, 3&gt; arr = {1, 2, 3}; 6 7 // 使用引用绑定直接修改元素 8 auto&amp; [first, second, third] = arr; 9 first *= 10; 10 second *= 10; 11 third *= 10; 12 13 std::cout &lt;&lt; &#34;Modified: &#34; &lt;&lt; arr[0] &lt;&lt; &#34;, &#34; 14 &lt;&lt; arr[1] &lt;&lt; &#34;, &#34; &lt;&lt; arr[2] &lt;&lt; &#34;\n&#34;; 15 // 输出: Modified: 10, 20, 30 16} 17 18int main() { 19 modifyArray(); 20 return 0; 21} 与if constexpr的协同应用 if constexpr的编译期条件判断 if constexpr是C++17的另一项重要特性，它在编译期评估条件，根据结果选择要编译的代码分支，未被选择的分支在编译时会被完全忽略。</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://example.org/%E6%97%A5%E5%B8%B8%E6%8B%BE%E8%B6%A3/c++11/c++17+/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A1/index.xml" rel="self" type="application/rss+xml" />
  </channel>
</rss>